# 简单用途

悬线法主要用途：

> 求一个只包含两种元素的矩形中，一个只包含其中一种元素的矩形（或正方形）的最大面积（边长）。
>
>  **悬线法适合解决求一个限制条件较多的最大子矩阵问题。** 

所以他的本质是 $Dp$，无语。

# 正确性

为什么正确？不正确也就不会去学了。

不过还得证明，真烦：

> 根据木桶原理：木桶装水的体积是由他最短的一块木板决定的。
>
> 那么同理，从一个图形中找矩形也一定是由它的最短悬线确定。
>
> 那么那个最大的矩形也应该是有一根悬线确定的，所以找到了这根悬线，就可以求出最大面积。
>
> 而悬线与点一一对应，所以只要枚举了所有的点，就可以保证找到确定最大矩形的悬线。 

好有道理（雾。

# 模板？？（伪

分块的：

1. 初始化：

```cpp
int n, m; read(n, m);//一般都是输入原始矩形的长宽
for (int i = 1; i <= n; ++ i)
    for (int j = 1; j <= m; ++ j)
    {
        read(a[i][j]);
        l[i][j] = r[i][j] = j;//由此点向左的最大延伸宽度，右边同理
        Up[i][j] = 1;//代表目标矩形的最大高度（长）
    }
```

2. 向左右分别找出该悬线能拓展出的矩形的宽度：

```cpp
for (int i = 1; i <= n; ++ i)
    for (int j = 2; j <= m; ++ j)
        if (check() == true) l[i][j] = l[i][j - 1];//就这样向两边扩展
for (int i = 1; i <= n; ++ i)
    for (int j = m - 1; j >= 1; -- j)
        if (check() == true) r[i][j] = r[i][j + 1];//check() 表示题目的条件，具体对待了，而且一定要清楚，不然死了别喊冤
```

3. 但其实这还没完，下面还有最后的转移，包括 **找出每一个点对应的悬线的高度** ：

```cpp
for (int i = 1; i <= n; ++ i)
    for (int j = 1; j <= m; ++ j)
    {
		if (i > 1 && check() == true)
		{
			chkMin(l[i][j], l[i - 1][j]);
			chkMax(r[i][j], r[i - 1][j]);//完成未完成的宽度转移
			Up[i][j] = Up[i - 1][j] + 1;//这就是高度的转移了
		}
		chkMax(ans, Up[i][j] * (r[i][j] - l[i][j] + 1));//这时候就可以直接出答案了，分几种情况说说，比如个是最大矩形面积

		int b = min(Up[i][j], (r[i][j] - l[i][j] + 1));
		chkMax(ans, b * b);//最大正方形面积

		chkMax(ans, min(Up[i][j], (r[i][j] - l[i][j] + 1)));//这最大正方形的边长，最大矩形的边长应该是取 max，思考？？
	}
```

# 定义

然后扯了半天，定义都没说，呵呵。

悬线的定义是这样的：

**从每一个点向上走，知道遇到障碍点或顶边界。**

于是轻松地得到悬线的一些性质：

1. 每一个点对应一根悬线（或者说，每一个点都属于一根悬线？）；
2. 每一根悬线都对应了一个高度等于悬线高度，宽度大于 $0$ 的矩形（上面的木桶原理）。