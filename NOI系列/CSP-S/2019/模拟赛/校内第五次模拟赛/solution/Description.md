# <center>NOIP 模拟赛</center>

<center>By Magolor</center>
|  中文题目名称  |  硬币求和  |  汉诺塔   | 随机子树 |
| :------------: | :--------: | :-------: | :------: |
|    英文题目    |   scoins   |   hanoi   |   tree   |
|  可执行文件名  |   scoins   |   hanoi   |   tree   |
|   输入文件名   | scoins.in  | hanoi.in  | tree.in  |
|   输出文件名   | scoins.out | hanoi.out | tree.out |
| 每个测试点时限 |    0.5s    |   1.0s    |    2s    |
|   测试点数目   |     10     |    10     |    20    |
| 每个测试点分值 |     10     |    10     |    5     |
|  附加样例文件  |     有     |    有     |    有    |
|    题目类型    |    传统    |   传统    |   传统   |
|  运行内存上限  |    512M    |   512M    |   512M   |

**注意事项:**

1. 无特别声明时，结果比较方式为全文比较(过滤行末空格及文末回车)。
2. C++语言源程序名称为题目名.cpp，C语言源程序名称为题目名.c。
3. 编译命令`g++ -o 题目名 题目名.cpp -lm`或`gcc -o 题目名 题目名.c -lm`，不包含任何优化开关。开启无限栈(**这与NOIP不同**)。
4. 文件名(程序名和输入输出文件名)必须使用英文小写。
5. 函数`main()`的返回值类型必须是`int`，程序正常结束时返回值必须是`0`。
6. 评测在Windos 10环境下用`lemon`进行(**这与NOIP不同**)，对于`long long`类型使用`%lld`和`%I64d`都是可以接受的。实际评测时限可能更改。
7. 考试期间请保持安静，选手间不得相互交流，不得大喊"题目太难了！"，但是允许并提倡大喊"题目太简单，我AK了！"。

<br/>

<br/>

<br/>

<br/>

<br/>

# <center>硬币求和 <font size="2">scoins 每个测试点时限: 0.5s  运行内存上限: 512M</font></center>

【问题描述】

Magolor有一排$n$个纵截面积为$1$的硬币。这里硬币可以抽象为一个竖立着的圆柱，纵截面积就是圆柱的左视图面积。

每个硬币面值不一样，第$i$个硬币面值是$i$。面值越大的硬币面积当然应该越大。具体地，面值为$1$的硬币面积为$1$个单位圆的面积；对于所有硬币面积正比于面值。

现在请将$n$个硬币摞成一座塔(当然不能把硬币竖起来了)，要求相邻的硬币面值差不超过$3$。求这座塔的最小高度。请下取整输出。

由于浮点数存在较大的精度误差，只要误差不超过$\pm 1$即可。

【输入格式】

只有一行输入一个正整数$n$。

【输出格式】

只有一行输出一个非负整数表示最小高度，下取整输出。

【输入输出样例】

scoins_sample0.in:

```
2
```

scoins_sample0.out:

```
0
```

样例解释:

对于两个硬币的情况，第一个硬币面值为$1$，高度为$\frac{1}{2}$；第二个硬币面值为$2$，高度为$\frac{\sqrt{2}}{4}$。两个硬币的面值差总是不超过3，因此怎么摞都可以，高度都是$\frac{1}{2} + \frac{\sqrt 2}{4} \approx 0.853553$。

注意下取整后输出$0$，当然，输出$1$也会被视为正确(请不要输出$-1$，输出负数结果的正确性不予以保证)。

【数据规模与约定】

对于$10 \%$的数据满足$n \le 2$。

对于$30 \%$的数据满足$n \le 100$。

对于$50 \%$的数据满足$n \le 10^5$。

对于$70 \%$的数据满足$n \le 10^9$。

对于$100 \%$的数据满足$1 \le n \le 10^{18}$。

</br>

</br>

</br>

</br>

</br>

</br>

</br>

</br>

</br>

</br>

</br>

</br>

</br>

</br>

</br>

</br>

</br>

</br>

</br>

</br>

</br>

</br>

</br>

</br>

# <center>汉诺塔 <font size="2">hanoi 每个测试点时限: 1.0s  运行内存上限: 512M</font></center>

【问题描述】

Magolor对汉诺塔很感兴趣。但是他觉得只有$3$个柱子的汉诺塔并不能适应$OI$中计算机的强大计算力。别说$3$个柱子，就算是$4$个、$5$个......甚至$1500$个柱子的汉诺塔，~~用神威·太湖之光~~也可以轻松计算出来。

Magolor相信所有人都是这样认为的，于是他想:

> "既然大家都认为$1500$个柱子的汉诺塔是可以轻松解决的，那么我把这道题出出来一定就是一道送分题，能体现我~~凉心~~良心出题人的本质。"(大雾)

因此，给定一个有$n$个盘子的$m$阶汉诺塔(有$m$个柱子)，求最小步数。

【输入格式】

第一行输入一个正整数$T$代表数据组数。接下来$T$行每行两个正整数$n$和$m$。

【输出格式】

对于每组数据，输出一行一个数字表示最少所需步数。如果无论如何都无法达到目标，输出`No Solution`。

【输入输出样例】

hanoi_sample0.in:

```
2
5 3
5 4

```

hanoi_sample0.out:

```
31
13

```

样例解释:

汉诺塔的规则是这样的: 有$m$个柱子和$n$个大小分别为$1 \sim n$单位的圆环。一开始$n$个圆环串在编号为$1$的柱子上，从上往下圆环大小递增。每一步可以选择某个柱子上最上方的圆盘，将其移动到另外一个柱子最上方。要求每次移动后不存在某个大小更大的圆盘在某个大小更小的圆盘的同一根柱子的更上方。最后的目标是将$n$个圆环挪动到$m$号柱子上，从上往下圆环大小递增。

了解了汉诺塔的规则以后应该可以轻松手玩样例了。$>\_<$。

【数据规模与约定】

存在至少$10\%$的数据满足$n,m \le 5$。

另外存在至少$10\%$的数据满足$m \le 3$。

另外存在至少$20\%$的数据满足$m \le 4$。

对于$70\%$的数据都有$n,m \le 100$。

$70\%$以外，另外存在至少$10\%$的数据满足$T = 1$。

对于$100\%$的数据，都满足$1 \le n,m,T \le 1500$。

</br>

</br>

</br>

</br>

</br>

</br>

</br>

</br>

</br>

</br>

</br>

</br>

</br>

</br>

</br>

</br>

</br>

</br>

</br>

# <center>随机子树 <font size="2">tree 每个测试点时限: 2.5s  运行内存上限: 512M</font></center>

【问题描述】

Magolor拥有一棵$n$个点的树。

每天，Magolor会随机选择一个连通块(一棵子树)。Magolor想要确认这个连通块是毒瘤的，于是他会随机选择从一个点出发走向另一个点的最短路径巡视，巡视走过的距离是两个点之间唯一最短路径包含的边数。

Magolor不希望巡视距离太短，那样起不到有效检查；Magolor也不希望巡视距离太长，那样太累。于是他想问: 均匀随机选择一个连通块，有多大概率这一天巡视时有可能走过的最长距离也一定在$[L,R]$之间。

【输入格式】

只有一行输入三个正整数$n,L,R$。

接下来$n-1$行，每行两个正整数$u,v$表示$u,v$之间有一条边。保证输入是一棵树。

【输出格式】

只有一行输出一个整数。为$\mod{998244353}$意义下的概率。即如果答案可以表示成最简分数$\frac{p}{q}$，请输出$p \times q^{-1} \mod 998244353$，其中$q^{-1}$代表模意义下逆元。

【输入输出样例】

tree_sample0.in:

```
5 2 3
1 2
1 3
3 4
3 5

```

scoins_sample0.out:

```
528482305

```

样例解释:

这棵树总共有$17$种不同的子连通块，其中$[1],[2],[3],[4],[5]$最长巡视距离为$0$，$[1,2],[1,3],[3,4],[3,5]$最长巡视距离为$1$，$[1,2,3],[1,3,4],[1,3,5],[3,4,5],[1,3,4,5]$最长巡视距离为$2$，$[1,2,3,4],[1,2,3,5],[1,2,3,4,5]$最长巡视距离为$3$。因此最长巡视距离在$2 \sim 3$之间的概率为$\frac{5+3}{17} = \frac{8}{17}$。

【数据规模与约定】

对于$10 \%$的数据满足$n \le 5$。

对于$30 \%$的数据满足$n \le 100$。

对于$50 \%$的数据满足$n \le 5000$。

存在与这$50 \%$的数据不完全重合的$20\%$数据，满足树是一条链。

对于$100 \%$的数据满足$1 \le n \le 2 \times 10^5, 1 \le L \le R \le n$。数据存在梯度。

</br>
